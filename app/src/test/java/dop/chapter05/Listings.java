package dop.chapter05;

import dop.chapter05.FakeAnnotations.*;

import javax.annotation.Nullable;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Currency;
import java.util.List;
import java.util.Optional;

/**
 * Chapter 5 takes all the modeling tools we've explored
 * so far and applies them to building a complex feature.
 * No more simple domains. No more isolated modeling. We
 * dive into the messy world of building software. That
 * means everything that makes it hard: databases, ORMS,
 * third party services (with APIs we don't control), and
 * the absolute worst thing of all: prior decisions.
 *
 * We'll learn how to work with all of these limitations
 * and produce clean, clear, data-oriented code.
 */
public class Listings {


    /**
     * ───────────────────────────────────────────────────────
     * Listing 5.1
     * ───────────────────────────────────────────────────────
     * We're implementing the feature in an application that
     * already "exists." So, the first thing we do in the chapter
     * is set the stage.
     *
     * This pretend app is "modern" and "service oriented." These
     * are the external APIs we'll interact with.
     * We cheat a bit and ignore stuff like HTTP and failures.
     */
    public void listing5_1() {
        interface RatingsAPI {
            enum CustomerStanding {GOOD, ACCEPTABLE, POOR}
            CustomerStanding getRating(String customerId);
        }

        interface ContractsAPI {
            enum PaymentTerms {NET_30, NET_60, END_OF_MONTH, DUE_ON_RECEIPT}
            PaymentTerms getPaymentTerms(String customerId);
        }

        interface ApprovalsAPI {
            enum Status {Pending, Approved, Denied}
            record Approval(String id, Status status){}
            record CreateApprovalRequest(/*...*/) {}
            Approval createApproval(CreateApprovalRequest request);
            Optional<Approval> getApproval(String approvalId);
        }

        interface billingAPI {
            enum Status {ACCEPTED, REJECTED}
            record SubmitInvoiceRequest(/*...*/) {}
            record BillingResponse(
                    Status status,
                    String invoiceId,
                    String error
            ){}
            BillingResponse submit(SubmitInvoiceRequest request);
        }
    }



    /**
     * ───────────────────────────────────────────────────────
     * Listing 5.2
     * ───────────────────────────────────────────────────────
     * The bedrock set of identity objects on which our application
     * is built. These are playing the role of "what's already there"
     * in our pretend application.
     *
     * Getters, setters, etc are omitted for brevity. (Assume they're
     * auto-generated by the annotation processor)
     */
    public void listing5_2() {
        // Implementation note:
        // this outer wrapping class is here so that all the definitions
        // below can "see" each other. Without it, references between the
        // classes wouldn't work. And, as a reminder, they're only defined
        // inside the methods for ease of isolation between the listings.
        class ___ {
            enum InvoiceType {LATEFEE, STANDARD};

            @Entity
            class LineItem {
                @Id
                String id;
                String description;
                BigDecimal charges;
                Currency currency;
            }

            class Address {
                String line1;
                String city;
                // and so on
            }

            @Entity
            class AuditInfo {
                @Id
                @OneToOne
                String invoiceId;
                 @ManyToMany
                 List<Invoice> includedInFee;
                @Nullable
                String cannotBillReason;
            }

            enum InvoiceStatus {OPEN, CLOSED}
            @Entity
            class Invoice {
                @Id
                String invoiceId;
                String customerId;
                @OneToMany
                List<LineItem> lineItems;
                InvoiceStatus status;
                LocalDate invoiceDate;
                LocalDate dueDate;
                InvoiceType type;
                @Nullable
                AuditInfo auditInfo;
            }

            @Entity
            class Customer {
                @Id
                String customerId;
                Address address;
                @Nullable
                String approvalId;
            }
        }
    }


    public void listing5_3() {
        // These services are all defined in listing 5.1
        interface RatingsAPI {}
        interface ContractsAPI {}
        interface ApprovalsAPI {}
        interface BillingAPI {}
        // These are never explicitly defined. We assume they're
        // standard Data Access Objects / Repositories. i.e. they
        // have CRUD methods like findAll() get(), save() etc..
        interface CustomerRepo {}
        interface InvoiceRepo {}
        interface RulesRepo {}
        interface FeesRepo {}

        class LateFeeChargingService {
            private RatingsAPI ratingsApi;
            private ContractsAPI contractsApi;
            private ApprovalsAPI approvalsApit;
            private BillingAPI billingApi;
            CustomerRepo customerRepo;
            InvoiceRepo invoiceRepo;
            RulesRepo rulesRepo;
            FeesRepo feesRepo;

            public void createLateFees() {
                // So we begin!
            }
        }

    }

}
